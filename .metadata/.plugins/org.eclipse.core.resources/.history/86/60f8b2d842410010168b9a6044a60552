package com.cts;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.time.LocalDateTime;
import java.util.Optional;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.modelmapper.ModelMapper;
import org.springframework.boot.test.context.SpringBootTest;

import com.cts.dto.UserDto;
import com.cts.entity.User;
import com.cts.exception.EmailAlreadyExistsException;
import com.cts.repository.UserRepository;
import com.cts.service.UserServiceImplement;


@SpringBootTest
class UserServiceApplicationTests {
	
	 @Mock
	    private UserRepository userRepository;

	    @Mock
	    private ModelMapper modelMapper;

	    @InjectMocks
	    private UserServiceImplement userService; // Assuming your service implementation is named UserServiceImpl

	    private UserDto userDto;
	    private UserDto userDto2;
	    private UserDto userDtoDeleted;
	    
	    
	    private User user;
	    private User user2;
	    private User userDeleted;
	    
	    
	    @BeforeEach
	    void setUp() {
	        userDto = new UserDto();
	        userDto.setEmail("test@example.com");
	        userDto.setPassword("password123");
	        userDto.setUserId(1L); // Adding ID for mapping purposes, though not directly used in addUser logic

	        user = new User();
	        user.setUserId(1L);
	        user.setEmail("test@example.com");
	        user.setPassword("password123");
	        user.setRole("user");
	        user.setCreatedDate(LocalDateTime.now());
	        user.setUpdatedDate(LocalDateTime.now());
	        user.setDeleted(false);
	        
	        
	        
	     // Non-deleted user 2
	        user2 = new User();
	        user2.setUserId(2L);
	        user2.setEmail("user2@example.com");
	        user2.setPassword("pass2");
	        user2.setRole("admin"); // Different role for variety
	        user2.setCreatedDate(LocalDateTime.now());
	        user2.setUpdatedDate(LocalDateTime.now());
	        user2.setDeleted(false);

	        userDto2 = new UserDto();
	        userDto2.setUserId(2L);
	        userDto2.setEmail("user2@example.com");
	        userDto2.setPassword("pass2");

	        // Deleted user
	        userDeleted = new User();
	        userDeleted.setUserId(3L);
	        userDeleted.setEmail("deleted@example.com");
	        userDeleted.setPassword("pass3");
	        userDeleted.setRole("user");
	        userDeleted.setCreatedDate(LocalDateTime.now());
	        userDeleted.setUpdatedDate(LocalDateTime.now());
	        userDeleted.setDeleted(true);

	        userDtoDeleted = new UserDto();
	        userDtoDeleted.setUserId(3L);
	        userDtoDeleted.setEmail("deleted@example.com");
	        userDtoDeleted.setPassword("pass3");
	        
	    }

	    @Test
	    @DisplayName("Should add a new user successfully when email does not exist")
	    void addUser_Success() {
	        // Given
	        when(userRepository.findByEmail(userDto.getEmail())).thenReturn(Optional.empty());
	        when(modelMapper.map(userDto, User.class)).thenReturn(user); // Map DTO to Entity
	        when(userRepository.save(any(User.class))).thenReturn(user); // Save the entity
	        when(modelMapper.map(user, UserDto.class)).thenReturn(userDto); // Map saved Entity back to DTO

	        // When
	        UserDto result = userService.addUser(userDto);

	        // Then
	        assertNotNull(result);
	        assertEquals(userDto.getEmail(), result.getEmail());
	        assertEquals(userDto.getUserId(), result.getUserId());
	        verify(userRepository, times(1)).findByEmail(userDto.getEmail());
	        verify(modelMapper, times(1)).map(userDto, User.class);
	        verify(userRepository, times(1)).save(any(User.class));

	        // Verify that password, role, dates, and deleted flag are set correctly on the user object before saving
	        verify(userRepository, times(1)).save(argThat(savedUser ->
	                savedUser.getPassword().equals(userDto.getPassword()) &&
	                savedUser.getRole().equals("user") &&
	                savedUser.getCreatedDate() != null &&
	                savedUser.getUpdatedDate() != null &&
	                !savedUser.isDeleted()
	        ));
	        verify(modelMapper, times(1)).map(user, UserDto.class);
	    }

	    @Test
	    @DisplayName("Should throw EmailAlreadyExistsException when email already exists")
	    void addUser_EmailAlreadyExists() {
	        // Given
	        when(userRepository.findByEmail(userDto.getEmail())).thenReturn(Optional.of(user));

	        // When / Then
	        EmailAlreadyExistsException thrown = assertThrows(EmailAlreadyExistsException.class, () -> {
	            userService.addUser(userDto);
	        });

	        assertEquals("Email Already Exists", thrown.getMessage());
	        verify(userRepository, times(1)).findByEmail(userDto.getEmail());
	        verify(modelMapper, never()).map(any(UserDto.class), any()); // No mapping should happen
	        verify(userRepository, never()).save(any(User.class)); // No save should happen
	    }
	    
	    
	    

}
